---
title: C/C++const与static关键字
date: 2023-11-14 17:29:06
tags:
	- C++
	- 朋辈导师
categories:
	- 2023-11
---

这一节主要给大家介绍C语言中经常令人迷惑的两个关键字const和static，考虑到大家的基础，我只在课堂上讲授最初级的内容，但是初级不等于不重要，也决不等于简单，相反，学好初级的内容在编程当中具有十分重要的意义，是各位今后理解更高级别代码的基石，希望大家对下面的内容做到精准掌握！后续，我会根据情况逐渐对这篇博客进行完善，补充一些更高级的用法和更深层次的知识，下面，让我们从内存开始——

## 内存布局

### Windows

Windows是闭源的，有版权保护，资料较少，不好深入研究每一个细节，至今仍有一些内部原理不被大家知晓。下图是一个典型的 Windows 32位程序的内存分布：
![Windows内存分布](../../public/image/win.jpg)(图片为什么又不能正常显示了！！！)

## const

### 是这样吗？
Me：
但是在我int &a = f（int b）的例子中，f函数返回的也是一个临时的整数值啊，为什么绑定到临时的整形上就不会错，绑定到临时的pair上就会错呢？
ChatGPT：
好问题！这涉及到 C++ 中的两种不同的语法和行为。

在 C++ 中，绑定到临时值的非 const 引用是允许的，但有一个重要的区别：

对于基本数据类型（如整数），非 const 引用可以绑定到临时值，因为整数是可修改的。

对于复杂的用户定义类型（如 pair<int, int>），非 const 引用不能直接绑定到临时值。这是因为，与整数不同，pair<int, int> 是一个复杂的对象，C++ 规定不能通过非 const 引用修改临时对象，以防止悬垂引用问题。

这就是为什么在你的原始代码中，当你尝试用非 const 引用绑定到 pair<int, int> 类型的临时值时，编译器报错的原因。而在 int &a = f(int b) 这种情况下，int 是一个基本数据类型，可以通过非 const 引用绑定到临时值。

如果你想要修改 pair<int, int> 类型的临时值，可以使用 const 引用：
```
cpp
const auto &[l1, r1] = f(s, i, i);
const auto &[l2, r2] = f(s, i, i + 1);
```
这样就能够避免编译错误。希望这能帮助解释这个问题。
---
这是真的吗？？？
